apiVersion: v1
kind: ConfigMap
metadata:
  name: pingdirectory-restore
data:
  restore.sh: |
    #!/bin/sh

    # Set Hooks directory
    export HOOKS_DIR=/opt/staging/hooks
    SCRIPT="${HOOKS_DIR}/90-restore-backup-s3.sh"
    test -z "${BACKUP_RESTORE_POD}" && export SERVER="${K8S_STATEFUL_SET_NAME}-0" || export SERVER="${BACKUP_RESTORE_POD}"


    delete_pvc() {
      /tmp/kubectl delete pvc pingdirectory-restore -n ${PING_CLOUD_NAMESPACE} --grace-period=0 --force
    }

    cleanup () {
      delete_pvc
    }

    disable_readiness_probe(){
    # redirect stdout to /dev/null and stderr to logs
    echo "Disabling readiness probe abefore beginning the restore"
          /tmp/kubectl exec "${SERVER}" -c pingdirectory -- sh -c \
               sed -i '2i exit 1' "${HOOKS_DIR}/85-readiness.sh" >/dev/null
    }

    # This guarantees that cleanup method will always run, even if the restore job exits due to an error
    trap "cleanup" EXIT

    # Install kubectl
    curl -sS https://storage.googleapis.com/kubernetes-release/release/"${KUBECTL_VERSION}"/bin/linux/amd64/kubectl \
    -o /tmp/kubectl

    chmod +x /tmp/kubectl

    NUM_REPLICAS=$(/tmp/kubectl get statefulset "${K8S_STATEFUL_SET_NAME}" -o jsonpath='{.spec.replicas}')
    echo "restore: number of replicas: ${NUM_REPLICAS}"

    disable_readiness_probe
     
    # doing a sleep for 30s before we kickoff the restore script
    sleep 30

    if test -x ${SCRIPT}; then
      # Execute restore script if user has the permissions
      echo "Running restore script for PingDirectory"
      ${SCRIPT}
    else
      echo "You don't have permissions to execute ${SCRIPT}. If you are overriding script be sure to give it execute permissions"
      exit 1
    fi